[{"name":"DebugParser","comment":"\n\n@docs ParsedLog, parse, parseValue\n@docs Config, defaultConfig\n\n","unions":[],"aliases":[{"name":"Config","comment":" Record for setting transformations for parsed output types.\n\nYou might need to transform debug values to something else than ElmValue type.\nDoing this after everything is parsed is quite performance heavy, so you can use this record and set the transformations\nthat are used during parsing yourself. e.g. Json.Encode.Value, Html or just a nicer string.\n\n","args":["a"],"type":"{ bool : Basics.Bool -> a, string : String.String -> a, char : Char.Char -> a, number : Basics.Float -> a, function : a, internals : a, unit : a, bytes : Basics.Int -> a, file : String.String -> a, list : List.List a -> a, array : List.List a -> a, set : List.List a -> a, tuple : List.List a -> a, customType : String.String -> List.List a -> a, record : List.List ( String.String, a ) -> a, dict : List.List ( a, a ) -> a }"},{"name":"ParsedLog","comment":" Alias to represent parsed log.\n\nTag is part of the log message before the first colon.\n\n","args":["a"],"type":"{ tag : String.String, value : a }"}],"values":[{"name":"defaultConfig","comment":" Default configuration for parsing debug log into ElmValue type\n","type":"DebugParser.Config DebugParser.ElmValue.ElmValue"},{"name":"parse","comment":" Try to parse Debug.log message.\n","type":"DebugParser.Config a -> String.String -> Result.Result String.String (DebugParser.ParsedLog a)"},{"name":"parseValue","comment":" This function parses only the debug value without a tag, e.g. output of Debug.toString\n","type":"DebugParser.Config a -> String.String -> Result.Result String.String a"}],"binops":[]},{"name":"DebugParser.ElmValue","comment":"\n\n@docs ElmValue, ExpandableValue, PlainValue, SequenceType, toggle, hasNestedValues\n\n","unions":[{"name":"ElmValue","comment":" Elm values that are parsed can be either plain values like Strings and Bools, or they can be expandable values like Records, Dicts etc.\n\nExpandable values has bool as their first parameter, which is used to indicate whether they are expanded or collapsed. This is used in UI\nto show either the short version of the expandable value or the full, expanded one. It is part of the parsed type because performance of adding\nit later on large models is really costly. This might change in the upcoming versions of this parser.\n\n","args":[],"cases":[["Plain",["DebugParser.ElmValue.PlainValue"]],["Expandable",["Basics.Bool","DebugParser.ElmValue.ExpandableValue"]]]},{"name":"ExpandableValue","comment":" Expandable values\n","args":[],"cases":[["ElmSequence",["DebugParser.ElmValue.SequenceType","List.List DebugParser.ElmValue.ElmValue"]],["ElmType",["String.String","List.List DebugParser.ElmValue.ElmValue"]],["ElmRecord",["List.List ( String.String, DebugParser.ElmValue.ElmValue )"]],["ElmDict",["List.List ( DebugParser.ElmValue.ElmValue, DebugParser.ElmValue.ElmValue )"]]]},{"name":"PlainValue","comment":" Plain values\n","args":[],"cases":[["ElmString",["String.String"]],["ElmChar",["Char.Char"]],["ElmNumber",["Basics.Float"]],["ElmBool",["Basics.Bool"]],["ElmFunction",[]],["ElmInternals",[]],["ElmUnit",[]],["ElmFile",["String.String"]],["ElmBytes",["Basics.Int"]]]},{"name":"SequenceType","comment":" Sequence type\n\nAll List-like structures are the same, so we parsed them into `ElmSequence` type. However we would like to keep the information about which\ntype the sequence was.\n\n","args":[],"cases":[["SeqSet",[]],["SeqList",[]],["SeqArray",[]],["SeqTuple",[]]]}],"aliases":[],"values":[{"name":"hasNestedValues","comment":" Determines whether value has any nested childrens.\n","type":"DebugParser.ElmValue.ElmValue -> Basics.Bool"},{"name":"toggle","comment":" Toggle isExpanded flag for `ExpandableValue`\n","type":"DebugParser.ElmValue.ElmValue -> DebugParser.ElmValue.ElmValue"}],"binops":[]},{"name":"DebugParser.Path","comment":"\n\n@docs Path, initPath, indexFromPath, mapValuesWithPath, toggleValueByPath\n\n","unions":[{"name":"Path","comment":" Path to uniquely identify nested expandable value. It is used to e.g. toggle specific expandable value, so you can expand and collapse it.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"indexFromPath","comment":" Extracts index of nested value from it's path\n","type":"DebugParser.Path.Path -> Basics.Int"},{"name":"initPath","comment":" Initial path. It is used as the top level starting point\n","type":"DebugParser.Path.Path"},{"name":"mapValuesWithPath","comment":" Useful if you want to render nested values and you would like to make them clickable. Think of this as `List.mapIndex` but with Path instead of index.\n","type":"DebugParser.Path.Path -> (DebugParser.Path.Path -> a -> b) -> List.List a -> List.List b"},{"name":"toggleValueByPath","comment":" Given a path and a top level value you can expand and collapse nested expandable values.\n","type":"DebugParser.Path.Path -> DebugParser.ElmValue.ElmValue -> DebugParser.ElmValue.ElmValue"}],"binops":[]}]